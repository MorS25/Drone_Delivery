<html>
	<head>
		<meta charset=utf-8 />
		<title>SFmap</title>

		<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no' />
		<script src='https://api.tiles.mapbox.com/mapbox.js/v1.6.2/mapbox.js'></script>
		<link href='https://api.tiles.mapbox.com/mapbox.js/v1.6.2/mapbox.css' rel='stylesheet' />
		<link rel="stylesheet" href="/static/css/bootstrap.min.css">
         <!-- <script type="text/javascript" src="/static/js/bootstrap.js"></script> -->
        <script type="text/javascript" src="/static/js/jquery-2.0.3.min.js"></script>
        <script type="text/javascript" src="/static/js/pathfinding-browser.min.js"></script>

		<style>
  		body { margin:0; padding:0; }
  		#map { position:absolute; top:0; bottom:0; width:100%; }
		</style>
	</head>
	<body>
		<div id='map'></div>
		<script>
		//This import the map from mapbox. The map was created with the mapbox API and markers are place for all the tall buildings. A csv file of all the LatLong info of buildings over 118m are created by getting the data from Skyscrapperpage.com. This csv file is then loaded on to the mapbox API to draw the SFmap.
		var map = L.mapbox.map('map', 'cathylouie.hk0a096c')
    	.setView([37.79, -122.41], 15);

    	// Create array of lat,lon points for map area
		var line_points = [
    	[37.800000, -122.436000],
    	[37.800000, -122.386000],
    	[37.780000, -122.386000],
    	[37.780000, -122.436000],
    	[37.800000, -122.436000]
		];

		// Define polyline options
		// http://leafletjs.com/reference.html#polyline
		var polyline_options = {
    	color: '#000'

		};
		// var polyline = L.polyline(line_points, polyline_options).addTo(map);
		// //vert line 0.000250 by 0.000250 degree
		// for (var i = 0; i < 499; i++){
		// 	var line_points = [
  //   		[37.800000, -122.386100-i*0.000100],
  //   		[37.780000, -122.386100-i*0.000100]
		// 	];
			
		// 	var polyline_options = {
  //   		color: 'red'
		// 	};
		// 	var polyline = L.polyline(line_points, polyline_options).addTo(map);
		// }

		// //hori line 0.000250 by 0.000250 degree
		// for (var i = 0; i < 199; i++){
		// 	var line_points = [
  //   		[37.799900-i*0.000100, -122.436000],
  //   		[37.799900-i*0.000100, -122.386000]
		// 	];
			
		// 	var polyline_options = {
  //   		color: 'blue'
		// 	};
		// 	var polyline = L.polyline(line_points, polyline_options).addTo(map);
		// }
        //Change building co-ordinates from LatLng to nodes 
		// //for the a* algorithum.
		var a = [122.402756, 122.403770, 122.400444, 122.396187, 122.399612, 122.392174, 122.397263, 122.397942, 122.400352, 122.396210, 122.401878, 122.394508, 122.401276, 122.398880, 122.402679, 122.399162, 122.398163, 122.410965, 122.403313, 122.403061, 122.395729, 122.398575, 122.397430, 122.401367, 122.398994, 122.397156, 122.397423, 122.405205, 122.400009, 122.390633, 122.397209, 122.404312, 122.402702, 122.399483, 122.401955, 122.395004, 122.397385, 122.400810, 122.394470, 122.400459, 122.402512, 122.404495, 122.399231, 122.409309, 122.403351, 122.398491];
		var xlist = [];

		for (var i = 0; i < a.length; i++){
		//change Lng to x of node
		if (((122.436000-a[i])*1000000)%100 !== 0){
			var x = parseInt((122.436000-a[i])*1000000/100); 
		 	}
		else
		 	{x = (122.436000-a[i])*1000000/100;
		 	}
		xlist.push(x);
		}
		var b = [37.795132, 37.792061, 37.792572, 37.790375, 37.794430, 37.785728, 37.790447, 37.792801, 37.789520, 37.795254, 37.789810, 37.793236, 37.790363, 37.791775, 37.788738, 37.790470, 37.791172, 37.785347, 37.789165, 37.790554, 37.791744, 37.788483, 37.794033, 37.786339, 37.792572, 37.791203, 37.791885, 37.792824, 37.786674, 37.789383, 37.793186, 37.785385, 37.791359, 37.788761, 37.786644, 37.791176, 37.795090, 37.789204, 37.791813, 37.793839, 37.790421, 37.786320, 37.795593, 37.787701, 37.793938, 37.794949];
		var ylist = [];

		for (var i = 0; i < b.length; i++){	
		//change Lat to y of node
		if (((37.800000-b[i])*1000000)%100 !== 0){
		 	var y = parseInt((37.800000-b[i])*1000000/100); 
		 	}
		else
		 	{y = (37.800000-b[i])*1000000/100;
		 	}
		ylist.push(y); 	
		}
		console.log(xlist,ylist);
		console.log(xlist[34],ylist[34]);
		console.log(xlist[35],ylist[35]);
		console.log(xlist[36],ylist[36]);
		//build a a* grid of 500 width by 200 height
		var grid = new PF.Grid(500, 200);
        //set nodes of all building nodes + 8 surrounding nodes
        //to be un-walkable.
        for (var i = 0; i < 46; i++){

	        grid.setWalkableAt(xlist[i], ylist[i], false);
	        //nodes immediately adjacent to xlist[i] and ylist[i]
	        grid.setWalkableAt(xlist[i]-1, ylist[i]-1, false);
	        grid.setWalkableAt(xlist[i], ylist[i]-1, false);
	        grid.setWalkableAt(xlist[i]+1, ylist[i]-1, false);
	        grid.setWalkableAt(xlist[i]-1, ylist[i], false);
	        grid.setWalkableAt(xlist[i]+1, ylist[i], false);
	        grid.setWalkableAt(xlist[i]-1, ylist[i]+1, false);
	        grid.setWalkableAt(xlist[i], ylist[i]+1, false);
	        grid.setWalkableAt(xlist[i]+1, ylist[i]+1, false);
	        //nodes adjacent to the above nodes
	        grid.setWalkableAt(xlist[i]-2, ylist[i]-2, false);
	        grid.setWalkableAt(xlist[i]-1, ylist[i]-2, false);
	        grid.setWalkableAt(xlist[i], ylist[i]-2, false);
	        grid.setWalkableAt(xlist[i]+1, ylist[i]-2, false);
	        grid.setWalkableAt(xlist[i]+2, ylist[i]-2, false);
	        grid.setWalkableAt(xlist[i]-2, ylist[i]-1, false);
	        grid.setWalkableAt(xlist[i]+2, ylist[i]-1, false);
	        grid.setWalkableAt(xlist[i]-2, ylist[i], false);
	        grid.setWalkableAt(xlist[i]+2, ylist[i], false);
	        grid.setWalkableAt(xlist[i]-2, ylist[i]+1, false);
	        grid.setWalkableAt(xlist[i]+2, ylist[i]+1, false);
	        grid.setWalkableAt(xlist[i]-2, ylist[i]+2, false);
	        grid.setWalkableAt(xlist[i]-1, ylist[i]+2, false);
	        grid.setWalkableAt(xlist[i], ylist[i]+2, false);
	        grid.setWalkableAt(xlist[i]+1, ylist[i]+2, false);
	        grid.setWalkableAt(xlist[i]+2, ylist[i]+2, false);  
       		
       		console.log(grid);
        }
      
            //build a path-finder with AStarFinder and using chebyshev heuristic 
            var finder = new PF.AStarFinder({
                heuristic: PF.Heuristic.chebyshev,
            	allowDiagonal: true,
            	dontCrossCorners: true
            });
            //To find a path from delivery center(420, 38) to customer address(a, b), (Note: both the start point and end point should be walkable):
            var path = finder.findPath(420, 38, 250, 199, grid);

            console.log(path);

            //Change nodes back to LatLng



        // Draw flight path
		// Create lat,lon points from the 'path' arrays.
		var line_points = [];
			for (var i = 0; i < path.length; i++){
				var p = [(37.800000 - path[i][1]*1/10000), - (122.436000 - path[i][0]*1/10000).toFixed(6)];

				line_points.push(p);
				}
		console.log(line_points);		
		// Define polyline options
		// http://leafletjs.com/reference.html#polyline
		var polyline_options = {
    	color: '#000'
		};

		// Defining a polygon here instead of a polyline will connect the
		// endpoints and fill the path.
		// http://leafletjs.com/reference.html#polygon
		var polyline = L.polyline(line_points, polyline_options).addTo(map);
		</script>
              
	</body>
</html>
